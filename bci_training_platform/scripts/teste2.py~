from scipy import signal as sig
import numpy as np
import os

def importa(nome_do_arquivo):
	return np.matrix([[float(x) for x in y] for y in [y.split('\t') for y in open(nome_do_arquivo,'r').read().split('\n')[0:-1]]]).T

def cov_(X):
	cov = X*X.T
	return cov/cov.trace()


def calcparams():
	print('calc params')
	classes=[3,4]
	globalpath=os.path.abspath(os.path.dirname(__file__))
	X=importa(globalpath+'/users/harion/samples.txt')
	X=X[0:8]
	Y=importa(globalpath+'/users/harion/marcas.txt')
	ind_T = np.argsort(Y[1].A1)
	Y[1] = Y[1].A1[ind_T]
	Y[0] = Y[0].A1[ind_T]
	fir=np.matrix(sig.firwin(21,[8,30],pass_zero=False,nyq=125.0))
	X_bp=np.matrix(sig.convolve(X,fir))
	X_T=[X_bp.T[y+3*250:y+6*250].T for y in Y.tolist()[0]]
	for classe1,el1 in enumerate(classes):
		for classe2,el2 in enumerate(classes):
			if classe2 > classe1:
					print(classe1)
					print(classe2)
					Xa = X_T[30*(classe1+1-1):30*(classe1+1)]          #array de matrizes de sinais da classe a
					Xb = X_T[30*(classe2+1-1):30*(classe2+1)]          #array de matrizes se sinais da classe b						
					Ca_ = [cov_(X) for X in Xa]                  #array de matrizes de covariancia da classe a
					Cb_ = [cov_(X) for X in Xb]
					Ca = sum(Ca_)/len(Ca_)
					Cb = sum(Cb_)/len(Cb_)
					C = Ca + Cb
					U,V = np.linalg.eigh(C)
					V = V[:,np.argsort(U)]
					U = np.matrix(np.diag(U[np.argsort(U)]))
					Q = np.sqrt(U.I)*V.T
					U2,V2 = np.linalg.eigh(Q*Ca*Q.T)
					V2 = V2[:,np.argsort(U2)]
					W = V2.T*Q
					W_n = 3
					W_ = W[np.arange(W_n).tolist() + \
							sorted((-1-np.arange(W_n)).tolist())]    #separa os 3 primeiros e os tres ultimos filtros espaciais
					W_csp=W_		#			
					Za = np.matrix((np.log10([np.diag(x) for x in [W_*X*W_.T for X in Ca_]])).T)
					Zb = np.matrix((np.log10([np.diag(x) for x in [W_*X*W_.T for X in Cb_]])).T)
					Ma, Mb = (sum(Za.T).T/len(Za.T)), (sum(Zb.T).T/len(Zb.T))
					Sa, Sb = (Za*Za.T - Ma*Ma.T), (Zb*Zb.T - Mb*Mb.T)
					W2 = (Sa + Sb).I * (Ma - Mb)
					W_lda=W2      #
					L = W2.T * (Ma + Mb) * 0.5
					print(L)
			#		print("in")

	C_ = [cov_(r) for r in X_T]

	temp = [W_csp*cf*W_csp.T for cf in C_]
	temp2=[np.matrix((np.log10(np.diag(tr))).T) for tr in temp]
	temp = [xf*W_lda for xf in temp2]

	kil=[]
	for d in temp:
		if d>L :
			kil.append(3)
		if d<L :
			kil.append(4)
	print('did')
	print(Y[1].tolist()[0])
	print(kil)
	val=0
	for a1,a2 in zip(Y[1].tolist()[0],kil):
		if a1==a2:
			val+=1
	print(val)

y = calcparams()

